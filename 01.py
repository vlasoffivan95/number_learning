# -*- coding: utf-8 -*-
"""23.11.01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17IjJAvIjjYYMdps4lxfAiu3FxXnqVg6R
"""

import numpy as np
from scipy import special
import matplotlib.pyplot as plt


class NeuralNetwork:
    def __init__(self, input_nodes, hidden_nodes, output_nodes, learning_rate):
        self.input_nodes = input_nodes
        self.hidden_nodes = hidden_nodes
        self.output_nodes = output_nodes
        self.learning_rate = learning_rate
        self.activation_function = lambda x: special.expit(x)
        self.wih = np.random.normal(loc=0.0, scale=pow(self.hidden_nodes, -0, 5),
                                    size=(self.hidden_nodes, self.input_nodes))
        self.who = np.random.normal(loc=0.0, scale=pow(self.output_nodes, -0, 5),
                                    size=(self.output_nodes, self.hidden_nodes))

    def train(self, inputs_list, targets_list):
        inputs = np.array(inputs_list, ndmin=2).transpose()
        targets = np.array(targets_list, ndmin=2).transpose()
        hidden_inputs = np.dot(self.wih, inputs)
        hidden_outputs = self.activation_function(hidden_inputs)
        final_inputs = np.dot(self.who, hidden_outputs)
        final_outputs = self.activation_function(final_inputs)
        output_errors = targets - final_outputs
        hidden_errors = np.dot(self.who.transpose(), output_errors)
        self.who += self.learning_rate * np.dot((output_errors * final_outputs * (1.0 - final_outputs)),
                                                hidden_outputs.transpose())
        self.wih += self.learning_rate * np.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)),
                                                inputs.transpose())

    def query(self, inputs_list):
        inputs = np.array(inputs_list, ndmin=2).transpose()
        hidden_inputs = np.dot(self.wih, inputs)
        hidden_outputs = self.activation_function(hidden_inputs)
        final_inputs = np.dot(self.who, hidden_outputs)
        final_outputs = self.activation_function(final_inputs)
        return final_outputs


i_n = 3
h_n = 3
o_n = 3
l_r = 0.3
nn1 = NeuralNetwork(input_nodes=i_n, hidden_nodes=h_n, output_nodes=o_n, learning_rate=l_r)
inp = [1.0, 0.5, -1.0]
res = nn1.query(inputs_list=inp)
print(res)

tar = [0.1, 0.9, 0.2]
for i in range(10000):
    nn1.train(inputs_list=inp, targets_list=tar)
res = nn1.query(inputs_list=inp)
print(res)

with open('mnist_train_100.csv', 'r') as data:
    data_list = data.readlines()
    for line in data_list[:3]:
        print(line)

ind = 19
arr = np.asfarray(data_list[ind].split(','))[1:].reshape(28, 28)
print(arr[0])
plt.imshow(arr, cmap='Greys');

n = 10
fig, axs = plt.subplots(n, n, figsize=(15, 15))
for i in range(n):
    for j in range(n):
        arr = np.asfarray(data_list[i * n + j].split(','))[1:].reshape(28, 28)
        axs[i, j].imshow(arr, cmap='Greys')
        axs[i, j].set_title(data_list[i * n + j][0], c='red');

i1 = 1
values = np.asfarray(data_list[i1].split(','))
scaled_input = values[1:] / 255.0 * 0.99 + 0.01
print(scaled_input)

targets = np.zeros(10) + 0.01
targets[int(values[0])] = 0.99

input_n = 784
hidden_n = 200
output_n = 10
learning_r = 0.1
nn2 = NeuralNetwork(input_nodes=input_n, hidden_nodes=hidden_n, output_nodes=output_n, learning_rate=learning_r)

epochs = 50
for e in range(epochs):
    for record in data_list:
        values = np.asfarray(record.split(','))
        scaled_input = values[1:] / 255.0 * 0.99 + 0.01
        targets = np.zeros(output_n) + 0.01
        targets[int(values[0])] = 0.99
        nn2.train(inputs_list=scaled_input, targets_list=targets)

test_data_file = open('mnist_test.csv', 'r')
test_data_list = test_data_file.readlines()[1:]
test_data_file.close()

scorecard = []
recognized = []
fact = []

for record in test_data_list:
    values = np.asfarray(record.split(','))
    correct_label = int(values[0])
    scaled_inputs = values[1:] / 255.0 * 0.99 + 0.01
    outputs = nn2.query(inputs_list=scaled_input)
    label = np.argmax(outputs)
    recognized.append(label)
    fact.append(correct_label)
    if label == correct_label:
        scorecard.append(1)
    else:
        scorecard.append(0)

print(sum(scorecard) / len(scorecard))









